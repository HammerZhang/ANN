% ======================================================================
%
% This script is used to test the ANNBP algorithm with several class of
% guassian distribution data set. 
% The test dataset was generated by function GenerateGD. The BP algorithm 
% was implement with function ANNBP. Firstly the ANN was trained and then
% the trained ANN was tested.
%
% @Author: Hammer Zhang
% @Time: 2016-1-6
%
% =======================================================================
%% 清屏
clear all; clc;
%% 生成高斯分布数据
% 测试数据集是由五个二元高斯分布生成的N点数据
% 设置SDM 参数
% N:数据样本数量 D:数据维度,D = 2 K:混合高斯模型含有的独立高斯分布数
% Mu:1-by-D-by-K matrix
Mu1 = [1,2]; Mu2 = [8,1]; Mu3 = [7,5]; Mu4 = [6,9]; Mu5 = [2,10];
Mu =[Mu1,Mu2,Mu3,Mu4,Mu5];
Mu = reshape(Mu,1,2,5);

% Sigma:D-by-D-by-K matrix
Sigma1 = [1,0;0,2]; Sigma2 = [2,0;0,3]; Sigma3 = [1,0;0,4];
Sigma4 = [3,0;0,5]; Sigma5 = [5,0;0,1];
Sigma = [Sigma1,Sigma2,Sigma3,Sigma4,Sigma5];
Sigma = reshape(Sigma,2,2,5);

N = 2000;                    % 每类高斯分布的样本点数
% R: 样本数据集，N-by-D matrix
input = GenerateGD(Mu,Sigma,N);
% label:样本数据类别标签
output_label = zeros(10000,5);
for i = 1 : 10000
    if i<2001 && i>0
        output_label(i,:) = [1,0,0,0,0];
    elseif i<4001 && i>2000
        output_label(i,:) = [0,1,0,0,0];
    elseif i<6001 && i>4000
        output_label(i,:) = [0,0,1,0,0];
    elseif i<8001 && i>6000
        output_label(i,:) = [0,0,0,1,0];
    elseif i<10001 && i>8000
        output_label(i,:) = [0,0,0,0,1];
    end
end

% 打乱数据，选取8000组数据用于训练，2000组数据用于测试
%从1到10000间随机排序
k=rand(1,10000);
[m,n]=sort(k);

%随机提取8000个样本为训练样本，2000个样本为预测样本
input_train=input(n(1:8000),:)';
output_train=output_label(n(1:8000),:)';
input_test=input(n(8001:10000),:)';
output_test=output_label(n(8001:10000),:)';

%输入数据归一化
[inputn,inputps]=mapminmax(input_train);

%% 训练神经网络
hiddenlyr_num = 5;
[whiddenlyr,woutputlyr,bhiddenlyr,boutputlyr,iternum] = BPANN(inputn',output_train',hiddenlyr_num);

%% 对测试数据分类
inputn_test_temp = mapminmax('apply',input_test,inputps);
inputn_test = inputn_test_temp';
fore = zeros(2000,5);
for i = 1 : 2000
    % 计算隐藏层输出
    hidden_out_temp = inputn_test(i,:) * whiddenlyr' + bhiddenlyr';
    denh = ones(1,hiddenlyr_num);
    hidden_out = denh ./ (1 + exp(-hidden_out_temp));
    
    % 计算输出层输出
    out_temp = hidden_out * woutputlyr' + boutputlyr';
    deno = ones(1,5);
    fore(i,:) = deno ./ (1 + exp(-out_temp));
end

%% 计算分类准确率
[t,output_fore] = max(fore,[],2);

% 预测网络误差
[ot,output_test_label] = max(output_test);
error = output_fore - output_test_label';

% 计算准确率
k1 = zeros(1,5);
for i = 1 : 2000
    if error(i) ~= 0
        switch output_test_label(i)
            case 1
                k1(1,1) = k1(1,1) + 1;
            case 2
                k1(1,2) = k1(1,2) + 1;
            case 3
                k1(1,3) = k1(1,3) + 1;
            case 4
                k1(1,4) = k1(1,4) + 1;
            case 5
                k1(1,5) = k1(1,5) + 1;
        end
    end
end

% 计算准确率
kk = sum(output_test,2);
accuracy = k1 ./ kk' * 100;
disp('正确率');
disp(accuracy);
                















